---
layout: post
title: "Lazy sequences and streams"
description: ""
category: programming
tags: [clojure, scala]
---
{% include JB/setup %}

Functional languages have the notion of *lazy sequences*, which are an abstraction of infinite sequences that are stored using a small, finite amount of memory.
The basic idea is to only call the function that generates the sequence when needed, and cache the results.
It would be quite wasteful to realize an entire infinite sequence before even using it.
With lazy sequences, you don't blow the stack and the elements in the sequence are not recalculated everytime.

Let's look at how the two most popular functional languages targeting the JVM implement lazy sequences.

Clojure has the `lazy-seq` macro to create lazy sequences.
Since most functions are lazy in Clojure, sequences generated by these functions are also lazy.
Here's what a lazy Fibonacci sequence in Clojure would look like.

<script src="https://gist.github.com/4364961.js?file=fibo.clj"><!-- Gist  --></script>

Scala has the `Stream[T]` class to represent a lazy list.
Interestingly, a stream is parameterized.
Here's what a Scala Fibonacci stream looks like.

<script src="https://gist.github.com/4364961.js?file=Fibo.scala"><!-- Gist  --></script>

Let's look at how these two implementations of a Fibonacci sequence match up against eachother in terms of performance.
In Clojure, the `time` macro can be used to time the time taken to evaluate a form.
There's really no equivalent in Scala, so let's implement our own.
We should be able to simply say `time(fiboLast(n))` or `time(fiboList(n))`.

<script src="https://gist.github.com/4364961.js?file=Time.scala"><!-- Gist  --></script>

And here are the results!

<style type="text/css">
  #postchart {
    width: 600px;
    height: 300px;
  }
</style>
<table border="0px">
  <tr>
    <td>
      <div id="postchart"></div>
    </td>
  </tr>
</table>

<script src="/assets/js/posts/lazy-sequences-and-streams.js" type="text/javascript">
</script>
