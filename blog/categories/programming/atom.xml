<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | darth10.github.com]]></title>
  <link href="http://darth10.github.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://darth10.github.com/"/>
  <updated>2013-03-06T20:22:38+05:30</updated>
  <id>http://darth10.github.com/</id>
  <author>
    <name><![CDATA[Akhil Wali]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lazy sequences and streams]]></title>
    <link href="http://darth10.github.com/blog/2013/01/25/lazy-sequences-and-streams/"/>
    <updated>2013-01-25T00:00:00+05:30</updated>
    <id>http://darth10.github.com/blog/2013/01/25/lazy-sequences-and-streams</id>
    <content type="html"><![CDATA[<p>Functional languages have the notion of <em>lazy sequences</em>, which are an abstraction of infinite sequences that are stored using a small, finite amount of memory.
It would be wasteful to realize an entire infinite sequence before even using it.
The basic idea is to only call the function that generates the sequence when needed, and cache the results.
With lazy sequences, you don't blow the stack and the elements in the sequence are not recalculated everytime.</p>

<p>Let's look at how the two most popular and functional JVM languages handle lazy sequences.</p>

<p>Clojure has the <code>lazy-seq</code> macro to create lazy sequences.
Since most functions are lazy in Clojure, sequences generated by these functions are also lazy.
Here's how the Fibonacci sequence is implemented in Clojure.</p>

<script src="https://gist.github.com/4364961.js?file=fibo.clj"><!-- Gist  --></script>


<p>This is a really elegant implementation that uses the lazy <code>iterate</code> function.</p>

<p>Scala has the parameterized <code>Stream[T]</code> class to represent a lazy list.
Here's what a Scala Fibonacci stream looks like.</p>

<script src="https://gist.github.com/4364961.js?file=Fibo.scala"><!-- Gist  --></script>


<p>This implementation uses the lazy right-associative <code>#::</code> function, which is actually the <code>Stream.cons</code> method.
There's also an implicit conversion from a sequence to a stream, from the <code>Stream</code> companion object.
I'm sure Haskell programmers will eagerly point out the need for a <code>zipWith</code> function.</p>

<p>Let's look at how these two implementations match up against eachother in terms of performance.
In Clojure, the <code>time</code> macro can be used to measure the time taken to evaluate a form.
There's really no equivalent in Scala, so let's implement our own.
We should be able to simply say <code>time(fiboLast(n))</code>, for example.</p>

<script src="https://gist.github.com/4364961.js?file=Time.scala"><!-- Gist  --></script>


<p>Note that the time taken to print the result of a statement in the REPL shouldn't be measured.
We can ensure this by binding the result to a variable.
This is done by using <code>val fibo = time(fiboLast(5000)</code> in Scala, and <code>(time (def fibo (fibo-last 5000)))</code> in Clojure, for example.
Memory usage can be ignored, as the GC is invoked unpredictably.</p>

<p>And here are the results!</p>



<table border="0px">
  <tr>
    <td>
      <div id="postchart"></div>
    </td>
  </tr>
</table>




<script src="http://darth10.github.com/assets/js/posts/lazy-sequences-and-streams.js" type="text/javascript">
</script>


<p>A weird observation in the Scala implementation is that <code>fiboList(1)</code> takes 8-10 milliseconds to evaluate.
But Scala actually performs better on average, which is mostly due to the use of static types.</p>

<p>Interestingly, the Clojure <code>fibo-list</code> function evaluates in constant time, which is less than a millisecond!
Clojure also fetches cached elements in the lazy sequence much faster than Scala.
However, <code>fibo-last</code> performs linearly since the <code>last</code> function has linear time-complexity.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The WebBrowser nightmare]]></title>
    <link href="http://darth10.github.com/blog/2012/09/23/the-webbrowser-nightmare/"/>
    <updated>2012-09-23T00:00:00+05:30</updated>
    <id>http://darth10.github.com/blog/2012/09/23/the-webbrowser-nightmare</id>
    <content type="html"><![CDATA[<p>I recently had to use the <code>WebBrowser</code> .NET component in a project.
The control is essentially Internet Explorer embedded in a <code>UserControl</code> component.
Although the facilities for JavaScript interoperability and DOM manipualtion are pretty great, the control fails to meet simpler needs.</p>

<p>To override keyboard input handing in the control, we need to set the <code>WebBrowserShortcutsEnabled</code> property to <code>false</code> and handle the <code>PreviewKeyDown</code> event.</p>

<script src="https://gist.github.com/4354971.js?file=Normal.cs"><!-- Gist --></script>


<p>Surprisingly, the <code>OnBrowserKeyInput</code> method is called twice; once when the key is pressed and another time when the key is released.
After some googling around, I found <a href="http://social.msdn.microsoft.com/Forums/en-US/csharpgeneral/thread/f83d3d71-ea3e-4b18-a610-30a91fae060e/">this discussion</a> on MSDN, and it turns out to be an accepted problem with the control. The workaround requires explicity maintaining state and is quite ugly.</p>

<script src="https://gist.github.com/4354971.js?file=Bad.cs"><!-- Gist --></script>


<p>And the nightmare only begins there. The control doesn't fire the event twice for some key combinations, and so the function ends up looking something like this.</p>

<script src="https://gist.github.com/4354971.js?file=Worse.cs"><!-- Gist --></script>


<p>The thing that bothered me most was that this was an accepted bug in the control. Even in the .NET 4.0 version.
The only way to figure out which keys made the event fire twice was by trial-and-error.
It's almost like Microsoft was telling me not to use my own keyboard handling for the control, which sucked.
The end result is some ugly and error prone code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Abstract and parameterized types]]></title>
    <link href="http://darth10.github.com/blog/2012/08/16/abstract-and-parameterized-types/"/>
    <updated>2012-08-16T00:00:00+05:30</updated>
    <id>http://darth10.github.com/blog/2012/08/16/abstract-and-parameterized-types</id>
    <content type="html"><![CDATA[<p>Scala supports both abstract and parameterized types, which are essentially revamped generics (in Java) or templates (in C++).</p>

<p>First off, methods can be parameterized, in order to abstract a generic type which can be used by it.
The <code>apply</code> method in companion objects is the best place to start.
Here's an example from the implementation of the <code>List</code> class in the Scala library.</p>

<script src="https://gist.github.com/4354753.js?file=List.scala"><!-- Gist  --></script>


<p>Classes and traits can be parameterized as well.</p>

<p>In most languages, types are designed to reduce casting, which can be an expensive operation.
Type systems also imply support for variance, i.e. <em>covariance</em> and <em>contravariance</em>.</p>

<p>However, consider the use of a parameterized type in a trait.
You <em>must</em> specify the parameterized type(s) in the deriving class, i.e. the deriving class <em>has</em> to be concrete.</p>

<script src="https://gist.github.com/4354753.js?file=SimpleJsonComment.scala"><!-- Gist  --></script>


<p><code>JsonComment</code> has to define the type <code>Comment</code> (Ok, I admit this is a really bad example), and it cannot omit the type.
Also, it's not possible to have members which are objects of the specified type.</p>

<p>Enter abstract types. Abstract types are types whose identity is not precisely known.
Deriving classes <em>may</em> specify the abstract type(s) in a base class.
As parameterized types have variance annotations, abstract types have <em>type bounds</em>.</p>

<script src="https://gist.github.com/4354753.js?file=AbstractedJsonComment.scala"><!-- Gist  --></script>


<p>Here, <code>AbstractJsonComment</code> omits specifying the type <code>F</code> which has to be a subclass of <code>DateFormat</code>.
The class <code>AbstractFormattedJsonComment</code> specifies <code>F</code>, but has to be abstract as it doesn't implement the functions in <code>FromJson</code>.
Thus, these two classes specify the abstract types separately, and <code>JsonComment</code> specifies the implementation.
Note that <code>FromJson</code> has a member of type <code>F</code>, which it uses to provide a partial implementation.</p>

<p>Almost any implementation with parameterized types can be turned into one with abstract types, and vice versa. However, abstract types make it easier to separate implementation and specification.</p>
]]></content>
  </entry>
  
</feed>
