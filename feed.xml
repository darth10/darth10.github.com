<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://darth10.github.io/' rel='self' type='application/rss+xml'/>
<title>
darth10.github.io
</title>
<link>
http://darth10.github.io/
</link>
<description>
darth10's blog
</description>
<lastBuildDate>
Tue, 25 Feb 2020 10:00:16 +1300
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://darth10.github.io/posts/linq-is-not-quick
</guid>
<link>
http://darth10.github.io/posts/linq-is-not-quick
</link>
<title>
LINQ Is Not Quick
</title>
<description>
&lt;p&gt;Let me just say that I am not particularly a fan of either  microbenchmarks or premature optimization. I also feel that &lt;a href='https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/introduction-to-linq-queries'&gt;LINQ&lt;/a&gt; extensions are a fine addition to the .NET standard library. The LINQ query syntax is also an integral part of the C# and F# languages.&lt;/p&gt;&lt;p&gt;That being said, there's an interesting and revealing tale to be told about the performance of &lt;a href='https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/linq-to-objects'&gt;LINQ to Objects&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;!&amp;ndash;more&amp;ndash;&gt;&lt;/p&gt;&lt;p&gt;LINQ provides a unified abstraction through a set of operations we can perform over any collection. Regardless of the underlying concrete collection of a given &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; object, we can invoke methods like &lt;code&gt;First&lt;/code&gt; to obtain the first element of the collection, or &lt;code&gt;Where&lt;/code&gt; to filter out elements that do not satisfy a supplied predicate. All of this sounds very compelling, and yet the &lt;a href='https://github.com/dotnet/roslyn/blob/5addcdeec3f2c4dc99b07507ca4f558aa91a0586/CONTRIBUTING.md#csharp'&gt;contributing guidelines of the Roslyn compiler&lt;/a&gt; recommend avoiding the use of LINQ in &lt;i&gt;compiler hot paths&lt;/i&gt; where performance is important.&lt;/p&gt;&lt;p&gt;Is LINQ really that bad for performance critical code? I thought I'd run a few  benchmarks using &lt;a href='https://github.com/dotnet/BenchmarkDotNet'&gt;BenchmarkDotNet&lt;/a&gt; to find out on my own.&lt;/p&gt;&lt;p&gt;If we have a reasonably sized collection, we can find the first element in it that matches a given predicate using the &lt;code&gt;First&lt;/code&gt; extension method. For example, in a collection of 100,000 integers, we can find the first element &lt;code&gt;i&lt;/code&gt; such that &lt;code&gt;i &amp;#42; 2&lt;/code&gt; is equal to &lt;code&gt;100000&lt;/code&gt; using &lt;code&gt;First&lt;/code&gt; as shown below.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;csharp&quot;&gt;List&amp;lt;int&amp;gt; itemsList = Enumerable.Range&amp;#40;0, 100000&amp;#41;.ToList&amp;#40;&amp;#41;;

int result = itemsList.First&amp;#40;i =&amp;gt; &amp;#40;i &amp;#42; 2&amp;#41; == 100000&amp;#41;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The imperative equivalent of using &lt;code&gt;First&lt;/code&gt; like this would be a combination of &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt; statements. Since the collection we're dealing with is a &lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt; object, we can also use methods such as &lt;code&gt;Find&lt;/code&gt; and &lt;code&gt;FindAll&lt;/code&gt; to achieve the same result. In fact, the &lt;a href='https://github.com/jackmott/LinqFaster'&gt;LinqFaster&lt;/a&gt; library wraps these methods in the &lt;code&gt;FirstF&lt;/code&gt; extension method.&lt;/p&gt;&lt;p&gt;Similarly, the &lt;code&gt;Select&lt;/code&gt; and &lt;code&gt;Where&lt;/code&gt; extension methods can be used to filter and transform elements in a collection. For example, we can find elements in the &lt;code&gt;itemsList&lt;/code&gt; collection that are multiples of &lt;code&gt;10&lt;/code&gt; and add &lt;code&gt;5&lt;/code&gt; to them as shown below.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;csharp&quot;&gt;var results = itemsList
    .Where&amp;#40;i =&amp;gt; i % 10 == 0&amp;#41;
    .Select&amp;#40;i =&amp;gt; i + 5&amp;#41;
    .ToList&amp;#40;&amp;#41;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again, the same result can be obtained using some combination of &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt; statements. You could even use the &lt;code&gt;ToArray&lt;/code&gt; and &lt;code&gt;CopyTo&lt;/code&gt; methods to avoid extra allocations. LinqFaster also provides the &lt;code&gt;WhereSelectF&lt;/code&gt; method for this exact pattern, which allows the LINQ query shown above to be written as  &lt;code&gt;itemsList.WhereSelectF&amp;#40;i =&amp;gt; i % 10 == 0, i =&amp;gt; i + 5&amp;#41;&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Let's benchmark the code shown above and also include results using arrays instead of lists. The code and results of this comparison can be found in &lt;a href='https://github.com/darth10/linq-performance'&gt;this repository&lt;/a&gt;. Here's a  summary of the results.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;|                     Method |      Mean |     Error |    StdDev | Allocated |
|----------------------------|-----------|-----------|-----------|-----------|
|         IterativeFirstList | 153.39 us | 2.3878 us | 2.1167 us |         - |
|              LinqFirstList | 478.37 us | 4.2302 us | 3.7500 us |      40 B |
|        LinqFasterFirstList | 138.72 us | 1.0194 us | 0.9036 us |         - |
|                            |           |           |           |           |
|        IterativeFirstArray |  30.63 us | 0.0569 us | 0.0444 us |         - |
|             LinqFirstArray | 390.25 us | 7.4436 us | 7.3106 us |      32 B |
|       LinqFasterFirstArray | 138.69 us | 1.2221 us | 1.1431 us |         - |
|                            |           |           |           |           |
|   IterativeWhereSelectList |  497.2 us |  9.904 us |  9.264 us | 128.33 KB |
|        LinqWhereSelectList |  462.0 us |  8.960 us |  8.381 us | 128.48 KB |
|  LinqFasterWhereSelectList |  457.1 us |  3.676 us |  3.439 us | 128.33 KB |
|                            |           |           |           |           |
|  IterativeWhereSelectArray |  225.4 us |  4.192 us |  4.305 us | 167.41 KB |
|       LinqWhereSelectArray |  411.0 us |  3.993 us |  3.540 us |  103.8 KB |
| LinqFasterWhereSelectArray |  415.5 us |  3.324 us |  2.947 us | 429.73 KB |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;div id=&quot;postchart1&quot; class=&quot;chart&quot;&gt;&lt;/div&gt;&lt;/p&gt;&lt;p&gt;The results show that using LINQ is slightly more performant than imperative approaches in only one case. Even in this case, the difference in performance is not really significant. LinqFaster also performs better than LINQ, but is generally slower on arrays compared to imperative code. In most cases however, imperative code is multiple times faster than LINQ. In the comparison between LINQ and &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;if&lt;/code&gt; statements to find the first element matching a predicate in an array, LINQ is &lt;i&gt;13 times&lt;/i&gt; slower!&lt;/p&gt;&lt;p&gt;Since the differences highlighted are in microseconds, we're treading in the territory of microbenchmarks. Also, all of the code used in these comparisons is CPU-bound, while real-world applications typically use more IO-bound code. In practice, the HTTP middleware of a web application could have a much higher impact on overall performance than the usage of LINQ.&lt;/p&gt;&lt;p&gt;LINQ is definitely useful in performing a complex series of operations on a given collection. This is essentially what LINQ provides - an abstraction of the &lt;a href='https://en.wikipedia.org/wiki/Iterator_pattern'&gt;iterator pattern&lt;/a&gt;. Of course, most data structures provide methods to efficiently use or traverse them. For example, &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; provides the &lt;code&gt;Find&lt;/code&gt; and &lt;code&gt;FindAll&lt;/code&gt; methods, and  similarly &lt;code&gt;Dictionary&amp;lt;K, V&amp;gt;&lt;/code&gt; has &lt;code&gt;ContainsKey&lt;/code&gt; and &lt;code&gt;GetValueOrDefault&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;The real argument against using LINQ is that it lets developers disregard choosing the right data structure to solve a problem. Avoiding LINQ can be thought of as premature optimization, but using &lt;code&gt;First&lt;/code&gt; instead of &lt;code&gt;&amp;#91;0&amp;#93;&lt;/code&gt; to obtain the first element of a list sounds more like &lt;i&gt;premature abstraction&lt;/i&gt;.  There's a great  &lt;a href='https://softwareengineering.stackexchange.com/questions/163185/torvalds-quote-about-good-programmer'&gt;quote by Linus Torvalds&lt;/a&gt;  regarding the use of appropriate data structures.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; &lt;i&gt;&quot;Bad programmers worry about the code.&lt;/i&gt; &lt;i&gt;Good programmers worry about data structures and their relationships.&quot;&lt;/i&gt; &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Developers often conflate premature optimization with understanding performance implications of certain features and writing code accordingly. Optimization largely involves lots of measurements through profiling and even digging into the generated IL or machine code if needed. There's practically no value to be gained from guessing where your performance bottlenecks are. If you know that a given method will be called frequently beforehand, it's definitely a good idea to implement something reasonably performant at the first go. That's probably  the reasoning behind the contributing guidelines of Roslyn, the C# compiler itself, stating that LINQ should be avoided in certain places.&lt;/p&gt;&lt;p&gt;To be fair, LINQ isn't really a part of the C# or F# languages. It's an assortment of extension methods in the standard library that you have to import through &lt;code&gt;using System.Linq;&lt;/code&gt;. Let's compare with Haskell, a language in which &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; are part of the core language constructs.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;items :: &amp;#91;Int&amp;#93;
items = &amp;#91;1..100000&amp;#93;

doSameThingAsFirst :: &amp;#91;Int&amp;#93; -&amp;gt; Int
doSameThingAsFirst xs = head $ filter &amp;#40;\i -&amp;gt; &amp;#40;i &amp;#42; 2&amp;#41; == 100000&amp;#41; xs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code can be compiled using the &lt;code&gt;-O2&lt;/code&gt; flag and benchmarked using the &lt;a href='https://hackage.haskell.org/package/criterion'&gt;criterion&lt;/a&gt; library.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;benchmarking doSameThingAsFirst/1
time                 180.8 μs   &amp;#40;179.2 μs .. 181.9 μs&amp;#41;
                     0.999 R²   &amp;#40;0.999 R² .. 1.000 R²&amp;#41;
mean                 180.3 μs   &amp;#40;179.2 μs .. 182.0 μs&amp;#41;
std dev              4.508 μs   &amp;#40;3.249 μs .. 7.936 μs&amp;#41;
variance introduced by outliers: 19% &amp;#40;moderately inflated&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;div id=&quot;postchart2&quot; class=&quot;chart&quot;&gt;&lt;/div&gt;&lt;/p&gt;&lt;p&gt;Looks like the Haskell equivalent is slower than imperative C# code by a tiny bit. It still performs significantly better than LINQ. So the next time you spot a &lt;code&gt;using System.Linq;&lt;/code&gt; statement in a program, you should think twice about the problem you're trying to solve. There are definitely good reasons to use LINQ, but performance shouldn't be one of them.&lt;/p&gt;&lt;p&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;linq-is-not-quick/chart.js&quot; defer&gt;&lt;/script&gt;&lt;/p&gt;
</description>
<pubDate>
Fri, 18 Oct 2019 00:00:00 +1300
</pubDate>
</item>
<item>
<guid>
http://darth10.github.io/posts/lazy-sequences-and-streams
</guid>
<link>
http://darth10.github.io/posts/lazy-sequences-and-streams
</link>
<title>
Lazy sequences and streams
</title>
<description>
&lt;p&gt;Functional languages have the notion of &lt;em&gt;lazy sequences&lt;/em&gt;, which are an abstraction of infinite sequences that are stored using a small, finite amount of memory. It would be wasteful to realize an entire infinite sequence before even using it. The basic idea is to only call the function that generates the sequence when needed, and cache the results. With lazy sequences, you don't blow the stack and the elements in the sequence are not recalculated everytime.&lt;/p&gt;&lt;p&gt;Let's look at how the two most popular and functional JVM languages handle lazy sequences.&lt;/p&gt;&lt;p&gt;&lt;!&amp;ndash;more&amp;ndash;&gt;&lt;/p&gt;&lt;p&gt;Clojure has the &lt;code&gt;lazy-seq&lt;/code&gt; macro to create lazy sequences. Since most functions are lazy in Clojure, sequences generated by these functions are also lazy. Here's how the Fibonacci sequence is implemented in Clojure.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;Clojure&quot;&gt;&amp;#40;def fibo-seq
  &amp;#40;map first
    &amp;#40;iterate &amp;#40;fn &amp;#91;&amp;#91;a b&amp;#93;&amp;#93; &amp;#91;b &amp;#40;+ a b&amp;#41;&amp;#93;&amp;#41; &amp;#91;0N 1N&amp;#93;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn fibo-list &amp;#91;n&amp;#93;
  &amp;#40;take n fibo-seq&amp;#41;&amp;#41;

&amp;#40;defn fibo-last &amp;#91;n&amp;#93;
  &amp;#40;last &amp;#40;fibo-list n&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a really elegant implementation that uses the lazy &lt;code&gt;iterate&lt;/code&gt; function.&lt;/p&gt;&lt;p&gt;Scala has the parameterized &lt;code&gt;Stream&amp;#91;T&amp;#93;&lt;/code&gt; class to represent a lazy list. Here's what a Scala Fibonacci stream looks like.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object Fibo {
  lazy val fibo: Stream&amp;#91;BigInt&amp;#93; =
    BigInt&amp;#40;0&amp;#41; #::
    BigInt&amp;#40;1&amp;#41; #::
    fibo.zip&amp;#40;fibo.tail&amp;#41;.map { n =&amp;gt; n.&amp;#95;1 + n.&amp;#95;2 }

  def fiboList = fibo.take&amp;#40;&amp;#95;: Int&amp;#41;.toList

  def fiboLast = fiboList&amp;#40;&amp;#95;: Int&amp;#41;.last
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This implementation uses the lazy right-associative &lt;code&gt;#::&lt;/code&gt; function, which is actually the &lt;code&gt;Stream.cons&lt;/code&gt; method. There's also an implicit conversion from a sequence to a stream, from the &lt;code&gt;Stream&lt;/code&gt; companion object. I'm sure Haskell programmers will eagerly point out the need for a &lt;code&gt;zipWith&lt;/code&gt; function.&lt;/p&gt;&lt;p&gt;Let's look at how these two implementations match up against eachother in terms of performance. In Clojure, the &lt;code&gt;time&lt;/code&gt; macro can be used to measure the time taken to evaluate a form. There's really no equivalent in Scala, so let's implement our own. We should be able to simply say &lt;code&gt;time&amp;#40;fiboLast&amp;#40;n&amp;#41;&amp;#41;&lt;/code&gt;, for example.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;def time&amp;#91;R&amp;#93;&amp;#40;block: =&amp;gt; R&amp;#41;: R = {
  val t0 = System.currentTimeMillis
  val result = block
  val t1 = System.currentTimeMillis

  println&amp;#40;&amp;quot;Elapsed time: &amp;quot; + &amp;#40;t1 - t0&amp;#41; + &amp;quot;ms&amp;quot;&amp;#41;
  result
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that the time taken to print the result of a statement in the REPL shouldn't be measured. We can ensure this by binding the result to a variable. This is done by using &lt;code&gt;val fibo = time&amp;#40;fiboLast&amp;#40;5000&amp;#41;&lt;/code&gt; in Scala, and &lt;code&gt;&amp;#40;time &amp;#40;def fibo &amp;#40;fibo-last 5000&amp;#41;&amp;#41;&amp;#41;&lt;/code&gt; in Clojure, for example. Memory usage can be ignored, as the GC is invoked unpredictably.&lt;/p&gt;&lt;p&gt;And here are the results!&lt;/p&gt;&lt;p&gt;&lt;div id=&quot;postchart&quot; class=&quot;chart&quot;&gt;&lt;/div&gt;&lt;/p&gt;&lt;p&gt;A weird observation in the Scala implementation is that &lt;code&gt;fiboList&amp;#40;1&amp;#41;&lt;/code&gt; takes 8-10 milliseconds to evaluate. But Scala actually performs better on average, which is mostly due to the use of static types.&lt;/p&gt;&lt;p&gt;Interestingly, the Clojure &lt;code&gt;fibo-list&lt;/code&gt; function evaluates in constant time, which is less than a millisecond! Clojure also fetches cached elements in the lazy sequence much faster than Scala. However, &lt;code&gt;fibo-last&lt;/code&gt; performs linearly since the &lt;code&gt;last&lt;/code&gt; function has linear time-complexity.&lt;/p&gt;&lt;p&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;lazy-sequences-and-streams/chart.js&quot; defer&gt;&lt;/script&gt;&lt;/p&gt;
</description>
<pubDate>
Fri, 25 Jan 2013 00:00:00 +1300
</pubDate>
</item>
<item>
<guid>
http://darth10.github.io/posts/the-webbrowser-nightmare
</guid>
<link>
http://darth10.github.io/posts/the-webbrowser-nightmare
</link>
<title>
The WebBrowser nightmare
</title>
<description>
&lt;p&gt;I recently had to use the &lt;code&gt;WebBrowser&lt;/code&gt; .NET component in a project. The control is essentially Internet Explorer embedded in a &lt;code&gt;UserControl&lt;/code&gt; component. Although the facilities for JavaScript interoperability and DOM manipualtion are pretty great, the control fails to meet simpler needs.&lt;/p&gt;&lt;p&gt;To override keyboard input handing in the control, we need to set the &lt;code&gt;WebBrowserShortcutsEnabled&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt; and handle the &lt;code&gt;PreviewKeyDown&lt;/code&gt; event.&lt;/p&gt;&lt;p&gt;&lt;!&amp;ndash;more&amp;ndash;&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;csharp&quot;&gt;public class MyControl : UserControl
{
    WebBrowser &amp;#95;webBrowser;

    // ...

    public MyControl&amp;#40;&amp;#41;
    {

        // ...

        &amp;#95;webBrowser.WebBrowserShortcutsEnabled = false;
        &amp;#95;webBrowser.PreviewKeyDown +=
            new PreviewKeyDownEventHandler&amp;#40;OnBrowserKeyInput&amp;#41;;
    }

    private void OnBrowserKeyInput&amp;#40;object sender, PreviewKeyDownEventArgs e&amp;#41;
    {
        if &amp;#40;e.KeyCode == Keys.W &amp;amp;&amp;amp;
            e.Modifiers == Keys.Control&amp;#41;
        {
            Debug.WriteLine&amp;#40;&amp;quot;C-w pressed&amp;quot;&amp;#41;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Surprisingly, the &lt;code&gt;OnBrowserKeyInput&lt;/code&gt; method is called twice; once when the key is pressed and another time when the key is released. After some googling around, I found &lt;a href='http://social.msdn.microsoft.com/Forums/en-US/csharpgeneral/thread/f83d3d71-ea3e-4b18-a610-30a91fae060e/'&gt;this discussion&lt;/a&gt; on MSDN, and it turns out to be an accepted problem with the control. The workaround requires explicity maintaining state and is quite ugly.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;csharp&quot;&gt;bool &amp;#95;skipNextKeyDown = false;

private void OnBrowserKeyInput&amp;#40;object sender, PreviewKeyDownEventArgs e&amp;#41;
{
    if &amp;#40;&amp;#95;skipNextKeyDown&amp;#41;
    {
        &amp;#95;skipNextKeyDown = false;
        return;
    }

    if &amp;#40;e.KeyCode == Keys.W &amp;amp;&amp;amp;
        e.Modifiers == Keys.Control&amp;#41;
    {
        Debug.WriteLine&amp;#40;&amp;quot;C-w pressed&amp;quot;&amp;#41;;
        &amp;#95;skipNextKeyDown = true;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And the nightmare only begins there. The control doesn't fire the event twice for some key combinations, and so the function ends up looking something like this.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;csharp&quot;&gt;bool &amp;#95;skipNextKeyDown = false;

private void OnBrowserKeyInput&amp;#40;object sender, PreviewKeyDownEventArgs e&amp;#41;
{
    if &amp;#40;e.KeyCode == Keys.W &amp;amp;&amp;amp;
        e.Modifiers == &amp;#40;Keys.Control | Keys.Alt&amp;#41;&amp;#41;
    {
        Debug.WriteLine&amp;#40;&amp;quot;C-M-w pressed&amp;quot;&amp;#41;;
        return;
    }

    if &amp;#40;&amp;#95;skipNextKeyDown&amp;#41;
    {
        &amp;#95;skipNextKeyDown = false;
        return;
    }

    if &amp;#40;e.KeyCode == Keys.W &amp;amp;&amp;amp;
        e.Modifiers == Keys.Control&amp;#41;
    {
        Debug.WriteLine&amp;#40;&amp;quot;C-w pressed&amp;quot;&amp;#41;;
        &amp;#95;skipNextKeyDown = true;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The thing that bothered me most was that this was an accepted bug in the control. Even in the .NET 4.0 version. The only way to figure out which keys made the event fire twice was by trial-and-error. It's almost like Microsoft was telling me not to use my own keyboard handling for the control, which sucked. The end result is some ugly and error prone code.&lt;/p&gt;
</description>
<pubDate>
Sun, 23 Sep 2012 00:00:00 +1200
</pubDate>
</item>
<item>
<guid>
http://darth10.github.io/posts/abstract-and-parameterized-types
</guid>
<link>
http://darth10.github.io/posts/abstract-and-parameterized-types
</link>
<title>
Abstract and parameterized types
</title>
<description>
&lt;p&gt;Scala supports both abstract and parameterized types, which are essentially revamped generics (in Java) or templates (in C++).&lt;/p&gt;&lt;p&gt;First off, methods can be parameterized, in order to abstract a generic type which can be used by it. The &lt;code&gt;apply&lt;/code&gt; method in companion objects is the best place to start. Here's an example from the implementation of the &lt;code&gt;List&lt;/code&gt; class in the Scala library.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object List {

  // ...

  def apply&amp;#91;A&amp;#93;&amp;#40;xs: A&amp;#42;&amp;#41;: List&amp;#91;A&amp;#93; = xs.toList
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Classes and traits can be parameterized as well.&lt;/p&gt;&lt;p&gt;In most languages, types are designed to reduce casting, which can be an expensive operation. Type systems also imply support for variance, i.e. &lt;em&gt;covariance&lt;/em&gt; and &lt;em&gt;contravariance&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;However, consider the use of a parameterized type in a trait. You &lt;em&gt;must&lt;/em&gt; specify the parameterized type(s) in the deriving class, i.e. the deriving class &lt;em&gt;has&lt;/em&gt; to be concrete.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;import java.util.SimpleDateFormat

trait JsonComment&amp;#91;T&amp;#93; {
  def fromJson: T
}

class JsonComment&amp;#40;comment: String, user: String, time: String&amp;#41;
  extends FromJson&amp;#91;Comment&amp;#93; {

  lazy val dateFormat = new SimpleDateFormat&amp;#40;&amp;quot;yyyy/MM/dd HH:mm:ss&amp;quot;&amp;#41;

  def fromJson = Comment&amp;#40;
    comment,
    user,
    dateFormat.parse&amp;#40;time&amp;#41;&amp;#41;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;JsonComment&lt;/code&gt; has to define the type &lt;code&gt;Comment&lt;/code&gt; (Ok, I admit this is a really bad example), and it cannot omit the type. Also, it's not possible to have members which are objects of the specified type.&lt;/p&gt;&lt;p&gt;Enter abstract types. Abstract types are types whose identity is not precisely known. Deriving classes &lt;em&gt;may&lt;/em&gt; specify the abstract type(s) in a base class. As parameterized types have variance annotations, abstract types have &lt;em&gt;type bounds&lt;/em&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;import java.util.{ DateFormat, SimpleDateFormat }

trait FromJson {
  type C
  type F &amp;lt;: DateFormat	// upper type bound specified

  val formatter: F

  def parseTime&amp;#40;date: String&amp;#41; = formatter.parse&amp;#40;date&amp;#41;

  def fromJson: C
}

abstract class AbstractJsonComment extends FromJson {
  type T = Comment
}

abstract class AbstractFormattedJsonComment extends AbstractJsonComment {
  type F = SimpleDateFormat
}

class JsonComment&amp;#40;comment: String, user: String, time: String&amp;#41;
  extends AbstractFormattedJsonComment {

  val formatter = new SimpleDateFormat&amp;#40;&amp;quot;yyyy/MM/dd HH:mm:ss&amp;quot;&amp;#41;

  def fromJson = Comment&amp;#40;
    comment,
    user,
    parseTime&amp;#40;time&amp;#41;&amp;#41;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, &lt;code&gt;AbstractJsonComment&lt;/code&gt; omits specifying the type &lt;code&gt;F&lt;/code&gt; which has to be a subclass of &lt;code&gt;DateFormat&lt;/code&gt;. The class &lt;code&gt;AbstractFormattedJsonComment&lt;/code&gt; specifies &lt;code&gt;F&lt;/code&gt;, but has to be abstract as it doesn't implement the functions in &lt;code&gt;FromJson&lt;/code&gt;. Thus, these two classes specify the abstract types separately, and &lt;code&gt;JsonComment&lt;/code&gt; specifies the implementation. Note that &lt;code&gt;FromJson&lt;/code&gt; has a member of type &lt;code&gt;F&lt;/code&gt;, which it uses to provide a partial implementation.&lt;/p&gt;&lt;p&gt;Almost any implementation with parameterized types can be turned into one with abstract types, and vice versa. However, abstract types make it easier to separate implementation and specification.&lt;/p&gt;
</description>
<pubDate>
Thu, 16 Aug 2012 00:00:00 +1200
</pubDate>
</item>
<item>
<guid>
http://darth10.github.io/posts/byte-selection-sort
</guid>
<link>
http://darth10.github.io/posts/byte-selection-sort
</link>
<title>
61 byte selection sort
</title>
<description>
&lt;p&gt;Here's the absolutely smallest array sorting function in C. It's written by &lt;a href=&quot;http://www.cs.dartmouth.edu/~doug/&quot;&gt;M. Doughlas McIlroy&lt;/a&gt; of Darthmouth College, NH USA. It only 67 bytes long (ignoring new-line characters), which is ridiculously impressive. In the function &lt;code&gt;s&lt;/code&gt; shown below, &lt;code&gt;a&lt;/code&gt; is the starting address of the array, and &lt;code&gt;b&lt;/code&gt; is the address of the last element plus one.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;s&amp;#40;int&amp;#42;a,int&amp;#42;b&amp;#41;
{for&amp;#40;int&amp;#42;c=b,t;c&amp;gt;a;&amp;#41;if&amp;#40;t=&amp;#42;c--,&amp;#42;c&amp;gt;t&amp;#41;c&amp;#91;1&amp;#93;=&amp;#42;c,&amp;#42;c=t,c=b;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This can be made even smaller using recursion and by inferring the type specifiers of global object declarations, which is a GCC hack. In the following function, &lt;code&gt;n&lt;/code&gt; is the number of elements in the array &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;s&amp;#40;a,n&amp;#41;int&amp;#42;a;
{n--&amp;gt;1?s&amp;#40;a,n&amp;#41;,s&amp;#40;a+1,n&amp;#41;,n=&amp;#42;a,&amp;#42;a=a&amp;#91;1&amp;#93;,a&amp;#91;n&amp;gt;&amp;#42;a&amp;#93;=n:0;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The sorting function &lt;code&gt;s&lt;/code&gt; is now only 61 bytes long!&lt;/p&gt;
</description>
<pubDate>
Wed, 13 Jan 2010 00:00:00 +1300
</pubDate>
</item>
<item>
<guid>
http://darth10.github.io/posts/network-packets-with-py
</guid>
<link>
http://darth10.github.io/posts/network-packets-with-py
</link>
<title>
Network packets with Python
</title>
<description>
&lt;p&gt;Next week, I'll have to start a project on implementing &lt;a href='https://en.wikipedia.org/wiki/Routing_Information_Protocol'&gt;RIP (Routing Information Protocol)&lt;/a&gt; using UDP sockets in C. I needed a quick way to get the byte structure of RIP packets, and decided to use &lt;a href=&quot;http://www.secdev.org/projects/scapy/&quot;&gt;scapy&lt;/a&gt;. It's quite a handy tool and has a simple interface, which is nothing more than an extended Python shell. Auto-completion is supported out-of-the-box, which is good news for all the command-line enthusiasts out there. Here's how we dump an RIP packet straight to a PDF file.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;$ scapy
Welcome to Scapy &amp;#40;2.3.3&amp;#41;
&amp;gt;&amp;gt;&amp;gt; entry = RIPEntry&amp;#40;addr='192.168.1.10', nextHop='192.168.1.1', mask='255.255.255.0'&amp;#41;
&amp;gt;&amp;gt;&amp;gt; entry.show&amp;#40;&amp;#41;
###&amp;#91; RIP entry &amp;#93;###
  AF= IP
  RouteTag= 0
  addr= 192.168.1.10
  mask= 255.255.255.0
  nextHop= 192.168.1.1
  metric= 1

&amp;gt;&amp;gt;&amp;gt; r = RIP&amp;#40;&amp;#41; / entry
&amp;gt;&amp;gt;&amp;gt; r.pdfdump&amp;#40;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This generates a self-explanatory packet dump. You could also use a different reader; just change the &lt;code&gt;conf.prog.pdfreader&lt;/code&gt; object.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;network-packets-with-py/packets.png&quot; alt=&quot;packets&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.secdev.org/projects/scapy/&quot;&gt;Scapy&lt;/a&gt; is more than just an educational tool. It comes with everything for network-induced chaos, from a sniffer to layer-2 sockets, and it's extensible through Python!&lt;/p&gt;
</description>
<pubDate>
Tue, 19 May 2009 00:00:00 +1200
</pubDate>
</item>
<item>
<guid>
http://darth10.github.io/posts/name-and-http-servers
</guid>
<link>
http://darth10.github.io/posts/name-and-http-servers
</link>
<title>
__name__ and HTTP servers
</title>
<description>
&lt;p&gt;The &lt;code&gt;&amp;#95;&amp;#95;name&amp;#95;&amp;#95;&lt;/code&gt; built-in Python variable which describes exactly that - it's the name of the module during runtime. Python modules use this variable to perform a particular action when the module is run, and probably do something else when imported by another module. It also facilitates module testing if you think about it.&lt;/p&gt;&lt;p&gt;Ideally, every Python module that is intended to be reused must have something like this in it, preferably at the end.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;if &amp;#95;&amp;#95;name&amp;#95;&amp;#95; == &amp;quot;&amp;#95;&amp;#95;main&amp;#95;&amp;#95;&amp;quot;:
    print &amp;quot;Just got executed!&amp;quot;
else:
    print &amp;quot;Got imported! I'm so cool!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Several modules that are part of the standard Python library use this in profound ways. For example, the &lt;code&gt;SimpleHTTPServer&lt;/code&gt; module, which is run as shown below, starts a simple HTTP-based file server hosting the current working directory.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ python -m SimpleHTTPServer
Serving HTTP on 0.0.0.0 port 8000 ...
127.0.0.1 - - &amp;#91;10/May/2009 18:55:05&amp;#93; &amp;quot;GET / HTTP/1.1&amp;quot; 200 -
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, don't overlook the use &lt;code&gt;&amp;#95;&amp;#95;name&amp;#95;&amp;#95;&lt;/code&gt; in your code thinking no one will actually like your puny little module.&lt;/p&gt;
</description>
<pubDate>
Wed, 13 May 2009 00:00:00 +1200
</pubDate>
</item>
</channel>
</rss>
